from functools import wraps
from types import FunctionType

import netCDF4

from iris.fileformats.cf import GLOBAL_NETCDF_ACCESS_LOCK

# Doesn't need thread protection, but this allows all netCDF4 refs to be
#  replaced with thread_safe refs.
default_fillvals = netCDF4.default_fillvals


def _use_nc_lock(func):
    """Acquire GLOBAL_NETCDF_ACCESS_LOCK while calling the function."""

    @wraps(func)
    def wrapped(self, *args, **kwargs):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            return func(self, *args, **kwargs)

    return wrapped


class NcLockMetaclass(type):
    """
    Wraps all methods in the class with _use_nc_lock decorator.
    """

    def __new__(mcs, name, bases, class_dict):
        new_class_dict = {}
        for attr_name, attr in class_dict.items():
            if isinstance(attr, FunctionType):
                attr = _use_nc_lock(attr)
            new_class_dict[attr_name] = attr
        return type.__new__(mcs, name, bases, new_class_dict)


class Dataset(netCDF4.Dataset, metaclass=NcLockMetaclass):
    """
    netCDF4.Dataset subclass that always acquires GLOBAL_NETCDF_ACCESS_LOCK.

    Subclassed as closely as possible - all attributes are simply wrapped to
    first acquire GLOBAL_NETCDF_ACCESS_LOCK.
    """

    def __init__(self, *args, **kwargs):
        # TODO: is this the only way to get __init__ wrapped? We lose the
        #  parent docstring and parameter list!
        super().__init__(*args, **kwargs)


class VariableContainer(object, metaclass=NcLockMetaclass):
    """
    Accessor for a netCDF4.Variable, always acquiring GLOBAL_NETCDF_ACCESS_LOCK.

    We never call Variable directly, so cannot subclass - generated by Dataset
    methods. Also cannot monkey-patch as the operations are in the C layer.

    """

    def __init__(self, var: netCDF4.Variable):
        # All methods are wrapped with use_nc_lock(), so we need to manually
        #  release the lock while we call __setattr__.
        GLOBAL_NETCDF_ACCESS_LOCK.release()
        self.__var = var
        GLOBAL_NETCDF_ACCESS_LOCK.acquire()

    def __getattr__(self, item):
        return getattr(self.__var, item)

    def __setattr__(self, key, value):
        if key == "_VariableContainer__var":
            object.__setattr__(self, key, value)
        else:
            return setattr(self.__var, key, value)

    def __getitem__(self, item):
        return self.__var.__getitem__(item)

    def __setitem__(self, key, value):
        return self.__var.__setitem__(key, value)

    # Please add documented attributes as needed for Iris' code.
    @property
    def dimensions(self):
        return self.__var.dimensions
