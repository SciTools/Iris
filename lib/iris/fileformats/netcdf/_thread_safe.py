# Copyright Iris contributors
#
# This file is part of Iris and is released under the LGPL license.
# See COPYING and COPYING.LESSER in the root of the repository for full
# licensing details.
"""
Module to ensure all calls to the netCDF4 library are thread-safe.

Intention is that no other Iris module should import the netCDF module.

"""
import netCDF4

from iris.fileformats.cf import GLOBAL_NETCDF_ACCESS_LOCK

# Doesn't need thread protection, but this allows all netCDF4 refs to be
#  replaced with thread_safe refs.
default_fillvals = netCDF4.default_fillvals


class ThreadSafeAggregator(object):
    # Allows easy assertions, without difficulties with isinstance and mocking.
    THREAD_SAFE_FLAG = True

    def __init__(self, contained):
        self.__contained = contained

    def __getattr__(self, item):
        if item == f"_{self.__class__.__name__}__contained":
            return object.__getattribute__(
                self, f"_{ThreadSafeAggregator.__name__}__contained"
            )
        else:
            with GLOBAL_NETCDF_ACCESS_LOCK:
                return getattr(self.__contained, item)

    def __setattr__(self, key, value):
        if key == f"_{ThreadSafeAggregator.__name__}__contained":
            object.__setattr__(self, key, value)
        else:
            with GLOBAL_NETCDF_ACCESS_LOCK:
                return setattr(self.__contained, key, value)

    def __getitem__(self, item):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            return self.__contained.__getitem__(item)

    def __setitem__(self, key, value):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            return self.__contained.__setitem__(key, value)


class VariableContainer(ThreadSafeAggregator):
    """
    Accessor for a netCDF4.Variable, always acquiring GLOBAL_NETCDF_ACCESS_LOCK.

    We never call Variable directly, so cannot subclass - generated by Dataset
    methods. Also cannot monkey-patch as the operations are in the C layer.

    """

    # Please add any attribute 'wrappers' as needed for Iris' code.
    @property
    def dimensions(self):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            return self.__contained.dimensions

    def setncattr(self, *args, **kwargs):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            return self.__contained.setncattr(*args, **kwargs)


class DatasetContainer(ThreadSafeAggregator):
    def __init__(self, *args, **kwargs):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            ds = netCDF4.Dataset(*args, **kwargs)
        super().__init__(ds)

    @property
    def variables(self):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            variables_ = self.__contained.variables
        return {k: VariableContainer(v) for k, v in variables_.items()}

    def createVariable(self, *args, **kwargs):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            new_variable = self.__contained.createVariable(*args, **kwargs)
        result = VariableContainer(new_variable)
        return result

    def get_variables_by_attributes(self, *args, **kwargs):
        with GLOBAL_NETCDF_ACCESS_LOCK:
            variables_ = self.__contained.get_variables_by_attributes(
                *args, **kwargs
            )
        return [VariableContainer(v) for v in variables_]
